; * * *
; This header information has been automaticaly generated by 
;
; Original author(s): Kwendenarmo (<kwendenarmo@akornsys-rdi.net>), see "AUTHORS".  
; File version: 0.01a, see "ChangeLog" and/or "NEWS".  
; Date: Jan. 14, 2014.  
; File: 'main.asm'.  
; Description: Programmable four channel DMX client for PIC MCU.  
; This file is part of 'DMX-RGBW Slave' project, see "README".  
; Licensed under [GPLv3](http://www.gnu.org/licenses/gpl-3.0.html), see "COPYING".  
; 
;   This program is free software: you can redistribute it and/or modify
;   it under the terms of the GNU General Public License as published by
;   the Free Software Foundation, either version 3 of the License, or
;   (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License
;   along with this program.  If not, see <http://www.gnu.org/licenses/>.
;
; * * *

; * * *
; {{{ # **Global system definitions** #

; {{{ _Processor files_
    LIST        P=PIC16F1508            ; list directive to define processor
    #INCLUDE    <p16f1508.inc>          ; processor specific variable definitions
; EOS Processor files }}}

; {{{ _Fuse definition_
; ## CONFIG1 __config 0xC984
    __CONFIG    _CONFIG1, _FOSC_INTOSC & _WDTE_OFF & _PWRTE_ON & _MCLRE_OFF & _CP_OFF & _BOREN_OFF & _CLKOUTEN_OFF & _IESO_OFF & _FCMEN_OFF
; ## CONFIG2 __config 0xDDFF
    __CONFIG    _CONFIG2, _WRT_OFF & _STVREN_OFF & _BORV_LO & _LPBOR_OFF & _LVP_OFF
; EOS Fuse definition }}}

; {{{ _I/O definition_
    #DEFINE     icpdat  PORTA,RA0       ; RA0 <> ICSP DAT
    #DEFINE     icpclk  PORTA,RA1       ; RA1 <- ICSP CLK
    #DEFINE     pwmb    PORTA,RA2       ; RA2 -> PWM B-CHANNEL
    #DEFINE     icpvpp  PORTA,RA3       ; RA3 <- ICSP VPP
    #DEFINE     mode    PORTA,RA4       ; RA4 <- BYTE/WORD MODE
    #DEFINE     debug   PORTA,RA5       ; RA5 -> DEBUG
    #DEFINE     addprg  PORTB,RB4       ; RB4 <- ADD PROG
    #DEFINE     commrx  PORTB,RB5       ; RB5 <- USART RX
    #DEFINE     drvdir  PORTB,RB6       ; RB6 -> DE/RE
    #DEFINE     commtx  PORTB,RB7       ; RB7 -> USART TX
    #DEFINE     pwmw    PORTC,RC1       ; RC1 -> PWM W-CHANNEL
    #DEFINE     pwmg    PORTC,RC3       ; RC3 -> PWM G-CHANNEL
    #DEFINE     pwmr    PORTC,RC5       ; RC5 -> PWM R-CHANNEL
; EOS I/O definition }}}

; {{{ _Command codes for communications_
CMD_SIGN    equ     0xFD                ; Prog Auth command
CMD_ACK     equ     0xF1                ; Prog ACK command
CMD_NCK     equ     0xF0                ; Prog NCK command
CMD_TOUT    equ     0xF5                ; Prog Timeout command
CMD_RADD    equ     0xFA                ; Prog Read address command
CMD_WADD    equ     0xFB                ; Prog Write address command
CMD_OFF     equ     0xFE                ; Prog Exit command
TMR_PRL     equ     0x00                ; TMR0 Preload value
TMR_STP     equ     0x08                ; TMR0 us step interrupt
; EOS Command codes for communications }}}

; {{{ _RAM definition_
    CBLOCK  0x20                        ; posiciones en banco 0
    DMX_DATRL
    DMX_DATRH
    DMX_DATGL
    DMX_DATGH
    DMX_DATBL
    DMX_DATBH
    DMX_DATWL
    DMX_DATWH
    PWM_DCRL
    PWM_DCRH
    PWM_DCGL
    PWM_DCGH
    PWM_DCBL
    PWM_DCBH
    PWM_DCWL
    PWM_DCWH
    PWM_AUX
    ENDC

    CBLOCK  0x70                        ; posiciones comunes en bancos
    DLOOP1
    DLOOP2
    MODE                                ; 8bit -> 0x00 // 16bit -> 0xFF
    DMX_ADDRESS
    DMX_AUXL
    DMX_AUXH
    PROG_TIMEOUT
    PROG_CMD
    TIM_USL
    TIM_USH
    TIM_USU
    TIM_USBL
    TIM_USBH
    TIM_USBU
    ENDC
; EOS RAM definition }}}

; EOS Global system definitions }}}
; * * *

; * * *
; {{{ # **Routines** #

; {{{ _Vectors_
RES_VECT    code    0x0000              ; processor reset vector
    call    setup
    goto    main

ISR_VECT    code    0x0004              ; processor isr vector
    goto    prog_mode

ADD_VECT    code    0x07e0              ; address prog vector
dmx_add
    retlw   0x00

MAIN_CODE   code                        ; let linker place main program
; EOS Vectors }}}

;isr
;    banksel TMR0
;    btfss   INTCON,TMR0IF
;    goto    $+0x0B
;    movlw   TMR_PRL
;    movwf   TMR0
;    movlw   TMR_STP
;    addwf   TIM_USL,F
;    btfsc   STATUS,C
;    goto    $+7
;    incf    TIM_USH,F
;    btfsc   STATUS,Z
;    incf    TIM_USU,F
;    goto    $+5
;    btfsc   INTCON,IOCIF
;    goto    prog_mode
;    goto    $+1
;    goto    $+1
;    bcf     INTCON,TMR0IF
;    retfie

; {{{ _Startup code_
setup
    ;CORE
    banksel OSCCON
    movlw   0x7B
    movwf   OSCCON
    movlw   0x1F
    movwf   PCON
    ;I/O
    banksel APFCON
    movlw   0x18
    movwf   APFCON
    banksel PORTA
    clrf    PORTA
    clrf    PORTB
    clrf    PORTC
    banksel LATA
    clrf    LATA
    clrf    LATB
    clrf    LATC
    banksel ANSELA
    clrf    ANSELA
    clrf    ANSELB
    clrf    ANSELC
    banksel WPUA
    movlw   0x10
    movwf   WPUA
    movwf   WPUB
    banksel TRISA
    movlw   0x14
    movwf   TRISA
    movlw   0x30
    movwf   TRISB
    movlw   0x2A
    movwf   TRISC
    banksel PORTB
    bcf     PORTB,6
    ;PWM
    banksel PWM1CON
    clrf    PWM1CON
    clrf    PWM2CON
    clrf    PWM3CON
    clrf    PWM4CON
    banksel PR2
    movlw   0xFF
    movwf   PR2
    banksel PWM1DCL
    clrf    PWM1DCL
    clrf    PWM2DCL
    clrf    PWM3DCL
    clrf    PWM4DCL
    clrf    PWM1DCH
    clrf    PWM2DCH
    clrf    PWM3DCH
    clrf    PWM4DCH
    banksel PIR1
    bcf     PIR1,TMR2IF
    movlw   0x01
    movwf   T2CON
    bsf     T2CON,TMR2ON
    banksel PWM1CON
    bsf     PWM1CON,PWM1EN
    bsf     PWM2CON,PWM2EN
    bsf     PWM3CON,PWM3EN
    bsf     PWM4CON,PWM4EN
    banksel PIR1
    btfss   PIR1,TMR2IF
    goto    $-1
    banksel TRISA
    bcf     TRISA,2
    bcf     TRISC,1
    bcf     TRISC,3
    bcf     TRISC,5
    banksel PWM1CON
    movlw   0xD0
    movwf   PWM1CON
    movwf   PWM2CON
    movwf   PWM3CON
    movwf   PWM4CON
    ;TIMER
    banksel OPTION_REG
    movlw   0x01
    movwf   OPTION_REG
    banksel TMR0
    movlw   TMR_PRL
    movwf   TMR0
    movlw   0x14
    movwf   T1CON
    bsf     T1CON,TMR1ON
    movlw   0xC1
    movwf   T1GCON
    ;USART
    ;spbrg=0xf
    ;16bits async (4)
    ;INT
    banksel PIE1
    clrf    PIE1
    clrf    PIE2
    clrf    PIE3
    banksel PIR1
    clrf    PIR1
    clrf    PIR2
    clrf    PIR3
    banksel IOCAP
    clrf    IOCAP
    clrf    IOCAN
    clrf    IOCAF
    clrf    IOCBP
    movlw   0x10
    movwf   IOCBN
    clrf    IOCBF
    movlw   0x88
    movwf   INTCON
    ; valores por defecto
    banksel PORTA
    clrf    MODE
    movlw   0xFF
    btfss   PORTA,4
    movwf   MODE
    movlw   HIGH dmx_add
    movwf   PCLATH
    call    dmx_add
    movwf   DMX_ADDRESS
    clrf    TIM_USL
    clrf    TIM_USH
    clrf    TIM_USU
    clrf    TIM_USBL
    clrf    TIM_USBH
    clrf    TIM_USBU
    clrf    DMX_DATRL
    clrf    DMX_DATRH
    clrf    DMX_DATGL
    clrf    DMX_DATGH
    clrf    DMX_DATBL
    clrf    DMX_DATBH
    clrf    DMX_DATWL
    clrf    DMX_DATWH
    return
; EOS Startup code }}}


main
    call    dmx_listen
;    call    set_dutycycle
;    goto    $-2
    goto    main

dmx_listen
    
;do
;  {
;    if (micros() - CM_lTimeBreak >= 1196) //tiempo entre breaks
;    {
;      while ((PINC & 0x01) == 0x01); //esperar flanco bajada MBB-BREAK
;      CM_lTimeBreak = micros();
;      while ((PINC & 0x01) == 0x00); //esperar flanco subida BREAK-MAB
;      if (micros() - CM_lTimeBreak >= 88) //tiempo minimo BREAK
;      {
;        CM_lTimeBreak = micros();
;        while ((PINC & 0x01) == 0x01); //esperar flanco bajada MAB-NULL SLOT
;        if ((micros() - CM_lTimeBreak >= 8)) //tiempo minimo MAB
;        {
;          cli();
;          CM_iSlotN = 0;
;          do
;          {
;            if (CM_iSlotN)
;            {
;              delayMicroseconds(3); //omitimos bit de start insertando 3us
;              asm("\tnop\n\tnop\n\tnop\n");
;            }
;            //Centramos la lectura en el centro de la se?al 2us
;            asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;            asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;            asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;            asm("\tnop\n\tnop\n");
;
;            for (CM_yLoopBit = 0; CM_yLoopBit < 8; CM_yLoopBit++)
;            {
;              PORTB |= 0x20;
;              CM_bDMX_Buffer[CM_yLoopBit] = (PINC & 0x01);
;              PORTB &= 0xDF;
;              //51x nop = 3187,5ns
;              asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;              asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;              asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;              asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;              asm("\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n\tnop\n");
;              asm("\tnop\n");
;            }
;            yDMX_Data[CM_iSlotN] = 0x00;
;
;            for (CM_yLoopBit = 0; CM_yLoopBit < 8; CM_yLoopBit++)
;            {
;              if (CM_bDMX_Buffer[CM_yLoopBit]) yDMX_Data[CM_iSlotN] |= 1 << CM_yLoopBit;
;            }
;            while (PINC & 0x01 == HIGH);
;          } while (++CM_iSlotN < 258);
;          sei();
;
;          //sacar datos por monitor
;          if (yDMX_Data[0] == 0x00)
;          {
;            analogWrite(pwm_r, yDMX_Data[CM_yChannel[0]+1]);
;            analogWrite(pwm_g, yDMX_Data[CM_yChannel[1]+1]);
;            Timer1.pwm(pwm_b, yDMX_Data[CM_yChannel[2]+1]*4);
;          }
;          CM_lTimeBreak = micros() + 11264; //11264 = 4us * 11bits * 256slots
;        }
;      }
;    }
;  } while (1);

;    banksel PORTB
;    ;asegura estar a LOW
;    btfsc   PORTB,5
;    goto    $-1
;    ;flanco subida MBB
;    btfss   PORTB,5
;    goto    $-1
;    bsf     PORTA,5
;    bcf     PORTA,5
;    clrf    TMR0
;    clrf    TMR1L
;    clrf    TMR1H
;    ;flanco bajada B
;    btfsc   PORTB,5
;    goto    $-1
;    clrf    TMR0
;    clrf    TMR1L
;    movf    TMR1H,W   ; MBB<1s?
;    andlw   0xF0
;    btfss   STATUS,Z
;    goto    dmx_listen
;    clrf    TIM_USU
;    clrf    TIM_USBL
;    clrf    TIM_USBH
;    clrf    TIM_USBU
;    ;flanco subida MAB
;    btfss   PORTB,5
;    goto    $-1
;    movf    TIM_USL,W   ; B>88us?
;    clrf    TIM_USL
;    sublw   0x57
;    btfsc   STATUS,C
;    goto    dmx_listen
;    movf    TIM_USU,W   ; B<1s?
;    andlw   0xF0
;    btfss   STATUS,Z
;    goto    dmx_listen
;    clrf    TIM_USU
;    ;flanco bajada F-STR
;    btfsc   PORTB,5
;    goto    $-1
;lframe
;
;;if start <2us
;;disable interrupts in frame
;;
;
;    clrf    DMX_AUXL
;    clrf    DMX_AUXH
;    ;START
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B0 LSB
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B1
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B2
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B3
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B4
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B5
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B6
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;B7 MSB
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;STOP
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;STOP
;    call    Delay_2us
;    bsf     PORTA,5
;    nop
;    bcf     PORTA,5
;    call    Delay_2us
;    ;IF
;    clrf    TIM_USL
;    clrf    TIM_USH
;    clrf    TIM_USU
;    btfsc   PORTB,5
;    goto    $-1
;    movf    TIM_USU,W   ; IF<1s?
;    andlw   0xF0
;    btfss   STATUS,Z
;    goto    dmx_listen
;    goto    dmx_listen
    return

set_dutycycle
    ;copy
    movlb   0x00
    movf    DMX_DATRL,W
    movwf   PWM_DCRL
    movf    DMX_DATRH,W
    movwf   PWM_DCRH
    movf    DMX_DATGL,W
    movwf   PWM_DCGL
    movf    DMX_DATGH,W
    movwf   PWM_DCGH
    movf    DMX_DATBL,W
    movwf   PWM_DCBL
    movf    DMX_DATBH,W
    movwf   PWM_DCBH
    movf    DMX_DATWL,W
    movwf   PWM_DCWL
    movf    DMX_DATWH,W
    movwf   PWM_DCWH
    ;align R
    movlw   0x03
    andwf   PWM_DCRH,F
    lslf    PWM_DCRH,F
    lslf    PWM_DCRH,F
    swapf   PWM_DCRH,F
    movf    PWM_DCRL,W
    movwf   PWM_AUX
    lsrf    PWM_AUX,F
    lsrf    PWM_AUX,W
    iorwf   PWM_DCRH,F
    movlw   0x03
    andwf   PWM_DCRL,F
    lslf    PWM_DCRL,F
    lslf    PWM_DCRL,F
    swapf   PWM_DCRL,F
    ;align G
    movlw   0x03
    andwf   PWM_DCGH,F
    lslf    PWM_DCGH,F
    lslf    PWM_DCGH,F
    swapf   PWM_DCGH,F
    movf    PWM_DCGL,W
    movwf   PWM_AUX
    lsrf    PWM_AUX,F
    lsrf    PWM_AUX,W
    iorwf   PWM_DCGH,F
    movlw   0x03
    andwf   PWM_DCGL,F
    lslf    PWM_DCGL,F
    lslf    PWM_DCGL,F
    swapf   PWM_DCGL,F
    ;align B
    movlw   0x03
    andwf   PWM_DCBH,F
    lslf    PWM_DCBH,F
    lslf    PWM_DCBH,F
    swapf   PWM_DCBH,F
    movf    PWM_DCBL,W
    movwf   PWM_AUX
    lsrf    PWM_AUX,F
    lsrf    PWM_AUX,W
    iorwf   PWM_DCBH,F
    movlw   0x03
    andwf   PWM_DCBL,F
    lslf    PWM_DCBL,F
    lslf    PWM_DCBL,F
    swapf   PWM_DCBL,F
    ;align W
    movlw   0x03
    andwf   PWM_DCWH,F
    lslf    PWM_DCWH,F
    lslf    PWM_DCWH,F
    swapf   PWM_DCWH,F
    movf    PWM_DCWL,W
    movwf   PWM_AUX
    lsrf    PWM_AUX,F
    lsrf    PWM_AUX,W
    iorwf   PWM_DCWH,F
    movlw   0x03
    andwf   PWM_DCWL,F
    lslf    PWM_DCWL,F
    lslf    PWM_DCWL,F
    swapf   PWM_DCWL,F
    ;set
    movf    PWM_DCRL,W
    banksel PWM1DCL
    movwf   PWM1DCL
    movlb   0x00
    movf    PWM_DCRH,W
    banksel PWM1DCH
    movwf   PWM1DCH
    movlb   0x00
    movf    PWM_DCGL,W
    banksel PWM2DCL
    movwf   PWM2DCL
    movlb   0x00
    movf    PWM_DCGH,W
    banksel PWM2DCH
    movwf   PWM2DCH
    movlb   0x00
    movf    PWM_DCBL,W
    banksel PWM3DCL
    movwf   PWM3DCL
    movlb   0x00
    movf    PWM_DCBH,W
    banksel PWM3DCH
    movwf   PWM3DCH
    movlb   0x00
    movf    PWM_DCWL,W
    banksel PWM4DCL
    movwf   PWM4DCL
    movlb   0x00
    movf    PWM_DCWH,W
    banksel PWM4DCH
    movwf   PWM4DCH
    return

prog_mode
    ;DEBUG
    banksel PORTA
    bsf     PORTA,5
    ;USART
    banksel SPBRGL
    movlw   0xA0
    movwf   SPBRGL
    movlw   0x01
    movwf   SPBRGH
    bcf     TXSTA,SYNC
    bsf     RCSTA,SPEN
    bsf     TXSTA,TXEN
    bsf     RCSTA,CREN
    bsf     TXSTA,BRGH
    movlw   0x08
    movwf   BAUDCON
    movlw   0x24
    movwf   TXSTA
    movlw   0x90
    movwf   RCSTA
    ;driver as receiver
    banksel PORTB
    bcf     PORTB,6
    ;prog or die
    call    read_serial_tout
    sublw   CMD_SIGN
    btfss   STATUS,Z
    goto    lexit
    movlw   CMD_SIGN
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
lmain
    ;prog loop
    call    read_serial_tout
    movwf   PROG_CMD
    sublw   CMD_RADD
    btfsc   STATUS,Z
    goto    lradd
    movf    PROG_CMD,W
    sublw   CMD_WADD
    btfsc   STATUS,Z
    goto    lwadd
    movf    PROG_CMD,W
    sublw   CMD_OFF
    btfsc   STATUS,Z
    goto    loff
    ;CMD unknow
    movlw   CMD_NCK
    call    send_serial
    goto    lmain
lradd
    ;CMD read
    movlw   CMD_RADD
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
    movlw   HIGH dmx_add
    movwf   PCLATH
    call    dmx_add
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
    goto    lmain
lwadd
    ;CMD write
    movlw   CMD_WADD
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
    call    read_serial_tout
    movwf   DMX_ADDRESS
    ;ERASE
    banksel PMADRL
    movlw   0xE0
    movwf   PMADRL
    movlw   0x07
    movwf   PMADRH
    bcf     PMCON1,CFGS
    bsf     PMCON1,FREE
    bsf     PMCON1,WREN
    movlw   0x55
    movwf   PMCON2
    movlw   0xAA
    movwf   PMCON2
    bsf     PMCON1,WR
    nop
    nop
    nop
    nop
    bcf     PMCON1,WREN
    ;WRITE
    movlw   0xE0
    movwf   PMADRL
    movlw   0x07
    movwf   PMADRH
    bcf     PMCON1,CFGS
    bcf     PMCON1,FREE
    bsf     PMCON1,LWLO
    bsf     PMCON1,WREN
    movf    DMX_ADDRESS,W
    movwf   PMDATL
    movlw   0x34
    movwf   PMDATH
    bcf     PMCON1,LWLO
    movlw   0x55
    movwf   PMCON2
    movlw   0xAA
    movwf   PMCON2
    bsf     PMCON1,WR
    nop
    nop
    nop
    nop
    bcf     PMCON1,WREN
    btfsc   PMCON1,WR
    goto    $-1
    movlw   HIGH dmx_add
    movwf   PCLATH
    call    dmx_add
    movwf   DMX_ADDRESS
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
    goto    lmain
loff
    ;CMD exit
    movlw   CMD_OFF
    call    send_serial
    movlw   CMD_ACK
    call    send_serial
lexit
    ;clean exit
    banksel IOCBF
    clrf    IOCBF
    reset

read_serial_tout
    movlw   0x01
    movwf   PROG_TIMEOUT
    banksel PIR1
    btfsc   PIR1,RCIF
    goto    $+9
    incf    PROG_TIMEOUT,F
    btfss   STATUS,Z
    goto    $+4
    movlw   CMD_TOUT
    call    send_serial
    reset
    call    Delay_10ms
    goto    $-9
    banksel RCREG
    movf    RCREG,W
    return

send_serial
    banksel PORTB
    bsf     PORTB,6
    banksel TXREG
    movwf   TXREG
    btfss   TXSTA,TRMT
    goto    $-1
    nop
    banksel PORTB
    bcf     PORTB,6
    return

;DELAY 10ms W/INT (5.6ms)
;Delay_10ms
;	movlw	0x7E
;	movwf	DLOOP1
;	movlw	0x12
;	movwf	DLOOP2
;Delay_10ms_0
;	decfsz	DLOOP1, f
;	goto	$+2
;	decfsz	DLOOP2, f
;	goto	Delay_10ms_0
;	goto	$+1
;	nop
;	return
Delay_10ms
    movlw   0x3E
    movwf   DLOOP1
    movlw   0x20
    movwf   DLOOP2
Delay_10ms_0
    decfsz  DLOOP1,F
    goto    $+2
    decfsz  DLOOP2,F
    goto    Delay_10ms_0
    goto    $+1
    nop
    return

Delay_2us
    movlw   0x19
    movwf   DLOOP1
Delay_2us_0
    decfsz  DLOOP1,F
    goto    Delay_2us_0
    return

    END                                 ; End of code
; EOS Routines }}}

; vim: set ts=4 sw=4 et foldmethod=syntax ft=mpasm: 
